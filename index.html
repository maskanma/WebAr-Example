<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>WebAR –ë—É–∫–ª–µ—Ç</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />

  <!-- –ë—ñ–±–ª—ñ–æ—Ç–µ–∫–∏ -->
  <script src="js/three.js"></script>
  <script src="jsartoolkit5/artoolkit.min.js"></script>
  <script src="jsartoolkit5/artoolkit.api.js"></script>
  <script src="threex/threex-artoolkitsource.js"></script>
  <script src="threex/threex-artoolkitcontext.js"></script>
  <script src="threex/threex-arbasecontrols.js"></script>
  <script src="threex/threex-armarkercontrols.js"></script>
</head>

<body style="margin: 0; overflow: hidden; font-family: sans-serif;">

  <!-- –ï–∫—Ä–∞–Ω –∑–∞–ø—É—Å–∫—É -->
  <div id="access" style="position: absolute; inset: 0; background: black; color: white; display: flex; align-items: center; justify-content: center; z-index: 2; text-align: center;">
    –ù–∞—Ç–∏—Å–Ω—ñ—Ç—å –Ω–∞ –µ–∫—Ä–∞–Ω –¥–ª—è –∑–∞–ø—É—Å–∫—É<br>WebAR-–±—É–∫–ª–µ—Ç—É ¬´–ö–ª–∞–≤—ñ–∞—Ç—É—Ä–∞¬ª
  </div>

  <!-- –õ–æ–∞–¥–µ—Ä -->
  <div id="loader" style="display: none; position: absolute; inset: 0; background: white; z-index: 1;">
    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
      <img src="data/spin.gif" alt="Loading" style="width: 100px;"><br>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...
    </div>
  </div>

  <script>
    let readyToPlay = false;
    let currentAudio = null;

    document.getElementById('access').addEventListener('click', () => {
      readyToPlay = true;
      document.getElementById('access').remove();
      document.getElementById('loader').style.display = 'block';
      startAR();
    });

    function startAR() {
      let scene, camera, renderer, clock;
      let arToolkitSource, arToolkitContext;
      let markerRoots = [];
      const patternNames = ["", "", "pattern.patt"];
      const patternBarcode = [1, 2, -1];
      const imageFiles = ["Screenshot_1.jpg", "Screenshot_2.jpg", "Screenshot_3.jpg"];
      const audioFiles = ["–ü–Ü–ë –û–∑–≤—É—á–∫–∞.ogg", "–ê–≤—Ç–æ—Ä –û–∑–≤—É—á–∫–∞.ogg", "–û–ø–∏—Å –û–∑–≤—É—á–∫–∞.ogg"];
      const htmlAudios = new Map();

      scene = new THREE.Scene();
      camera = new THREE.Camera();
      scene.add(camera);

      const light = new THREE.AmbientLight(0xffffff, 0.75);
      scene.add(light);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(640, 480);
      renderer.setClearColor(0x000000, 0);
      document.body.appendChild(renderer.domElement);

      clock = new THREE.Clock();

      arToolkitSource = new THREEx.ArToolkitSource({ sourceType: 'webcam' });
      arToolkitSource.init(() => onResize());
      window.addEventListener('resize', () => onResize());

      function onResize() {
        arToolkitSource.onResize();
        arToolkitSource.copySizeTo(renderer.domElement);
        if (arToolkitContext.arController) {
          arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
        }
      }

      arToolkitContext = new THREEx.ArToolkitContext({
        cameraParametersUrl: 'data/camera_para.dat',
        detectionMode: 'mono_and_matrix',
        matrixCodeType: '3x3',
        canvasWidth: 640,
        canvasHeight: 480
      });

      arToolkitContext.init(() => {
        camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
        document.getElementById('loader').style.display = 'none'; // ‚úÖ –ü—Ä–∏–±—Ä–∞—Ç–∏ –ª–æ–∞–¥–µ—Ä –ø—ñ—Å–ª—è —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó
      });

      for (let i = 0; i < 3; i++) {
        const markerRoot = new THREE.Group();
        scene.add(markerRoot);
        markerRoots.push(markerRoot);

        // üìå –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –∞–±–æ barcode –∞–±–æ pattern
        if (patternBarcode[i] === -1) {
          new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
            type: 'pattern',
            patternUrl: patternNames[i],
            size: 1
          });
        } else {
          new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
            type: 'barcode',
            barcodeValue: patternBarcode[i]
          });
        }

        // üñºÔ∏è –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(imageFiles[i], texture => {
          const geometry = new THREE.PlaneBufferGeometry(1, 1);
          const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.rotation.x = -Math.PI / 2;
          markerRoot.add(mesh);
        });

        // üîä –ê—É–¥—ñ–æ
        const audio = new Audio(audioFiles[i]);
        audio.preload = 'auto';
        audio.loop = false;
        const key = patternBarcode[i] === -1 ? patternNames[i] : patternBarcode[i];
        htmlAudios.set(key, audio);
      }

      function update() {
        if (arToolkitSource.ready) {
          arToolkitContext.update(arToolkitSource.domElement);

          for (let i = 0; i < 3; i++) {
            const key = patternBarcode[i] === -1 ? patternNames[i] : patternBarcode[i];
            const isVisible = patternBarcode[i] === -1
              ? arToolkitContext.arController.patternMarkers[i]?.inCurrent
              : arToolkitContext.arController.barcodeMarkers[key]?.inCurrent;

            const audio = htmlAudios.get(key);

            if (isVisible && readyToPlay) {
              if (currentAudio !== audio) {
                if (currentAudio && !currentAudio.paused) {
                  currentAudio.pause();
                  currentAudio.currentTime = 0;
                }
                audio.play();
                currentAudio = audio;
              }
            } else if (!isVisible && currentAudio === audio) {
              currentAudio.pause();
              currentAudio.currentTime = 0;
              currentAudio = null;
            }
          }
        }
      }

      function render() {
        renderer.render(scene, camera);
      }

      function animate() {
        requestAnimationFrame(animate);
        update();
        render();
      }

      animate();
    }
  </script>
</body>
</html>
