<<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>WebAR Буклет</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />

  <!-- Бібліотеки -->
  <script src="js/three.js"></script>
  <script src="jsartoolkit5/artoolkit.min.js"></script>
  <script src="jsartoolkit5/artoolkit.api.js"></script>
  <script src="threex/threex-artoolkitsource.js"></script>
  <script src="threex/threex-artoolkitcontext.js"></script>
  <script src="threex/threex-arbasecontrols.js"></script>
  <script src="threex/threex-armarkercontrols.js"></script>
</head>

<body style="margin: 0; overflow: hidden; font-family: sans-serif;">

  <!-- Екран запуску -->
  <div id="access" style="position: absolute; inset: 0; background: black; color: white; display: flex; align-items: center; justify-content: center; z-index: 2; text-align: center;">
    Натисніть на екран для запуску<br>WebAR-буклету «Клавіатура»
  </div>

  <!-- Лоадер -->
  <div id="loader" style="display: none; position: absolute; inset: 0; background: white; z-index: 1;">
    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
      <img src="data/spin.gif" alt="Loading" style="width: 100px;"><br>Завантаження...
    </div>
  </div>

  <script>
    let readyToPlay = false;
    let currentAudio = null;

    document.getElementById('access').addEventListener('click', () => {
      readyToPlay = true;
      document.getElementById('access').remove();
      document.getElementById('loader').style.display = 'block';
      startAR();
    });

    function startAR() {
      let scene, camera, renderer, clock;
      let arToolkitSource, arToolkitContext;
      let markerRoots = [];

      const patternNames = ["", "", "pattern.patt"];
      const patternBarcode = [1, 2, -1];
      const modes = ["image", "image", "image"];
      const modelFiles = ["", "", ""];
      const imageFiles = ["Screenshot_1.jpg", "Screenshot_2.jpg", "Screenshot_3.jpg"];
      const videoFiles = ["", "", ""];
      const audioFiles = ["ПІБ Озвучка.ogg", "Автор Озвучка.ogg", "Опис Озвучка.ogg"];
      const repeatOptions = ["false", "false", "false"];

      let htmlAudios = new Map();

      scene = new THREE.Scene();
      camera = new THREE.Camera();
      scene.add(camera);

      let light = new THREE.AmbientLight(0xffffff, 0.75);
      scene.add(light);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(640, 480);
      renderer.setClearColor(0x000000, 0);
      document.body.appendChild(renderer.domElement);

      clock = new THREE.Clock();

      arToolkitSource = new THREEx.ArToolkitSource({ sourceType: 'webcam' });
      arToolkitSource.init(() => onResize());
      window.addEventListener('resize', () => onResize());

      function onResize() {
        arToolkitSource.onResize();
        arToolkitSource.copySizeTo(renderer.domElement);
        if (arToolkitContext.arController) {
          arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
        }
      }

      arToolkitContext = new THREEx.ArToolkitContext({
        cameraParametersUrl: 'data/camera_para.dat',
        detectionMode: 'mono_and_matrix',
        matrixCodeType: '3x3',
        canvasWidth: 640,
        canvasHeight: 480
      });

      arToolkitContext.init(() => {
        camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
      });

      for (let i = 0; i < 3; i++) {
        const markerRoot = new THREE.Group();
        scene.add(markerRoot);
        markerRoots.push(markerRoot);

        if (patternBarcode[i] === -1) {
          new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
            type: 'pattern',
            patternUrl: patternNames[i],
            size: 1
          });
        } else {
          new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
            type: 'barcode',
            barcodeValue: patternBarcode[i]
          });
        }

        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(imageFiles[i], texture => {
          const geometry = new THREE.PlaneBufferGeometry(1, 1);
          const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.rotation.x = -Math.PI / 2;
          markerRoot.add(mesh);
        });

        const audio = new Audio(audioFiles[i]);
        audio.preload = 'auto';
        audio.loop = repeatOptions[i] === "true";
        const key = patternBarcode[i] === -1 ? patternNames[i] : patternBarcode[i];
        htmlAudios.set(key, audio);
      }

      document.getElementById('loader').style.display = 'none';

      function update() {
        if (arToolkitSource.ready) {
          arToolkitContext.update(arToolkitSource.domElement);

          for (let i = 0; i < 3; i++) {
            const key = patternBarcode[i] === -1 ? patternNames[i] : patternBarcode[i];
            const markerVisible = patternBarcode[i] === -1
              ? arToolkitContext.arController.patternMarkers?.find(p => p?.patternFile === patternNames[i])?.inCurrent
              : arToolkitContext.arController.barcodeMarkers[key]?.inCurrent;

            const audio = htmlAudios.get(key);

            if (markerVisible && readyToPlay) {
              if (currentAudio !== audio) {
                if (currentAudio && !currentAudio.paused) {
                  currentAudio.pause();
                  currentAudio.currentTime = 0;
                }
                audio.play();
                currentAudio = audio;
              }
            } else if (!markerVisible && currentAudio === audio) {
              currentAudio.pause();
              currentAudio.currentTime = 0;
              currentAudio = null;
            }
          }
        }
      }

      function render() {
        renderer.render(scene, camera);
      }

      function animate() {
        requestAnimationFrame(animate);
        update();
        render();
      }

      animate();
    }
  </script>
</body>
</html>
